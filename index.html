<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Online Whiteboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      overflow: hidden;
    }
    #toolbar {
      position: fixed;
      top: 0; left: 0; right: 350px;
      height: 60px;
      background: #fff;
      border-bottom: 1px solid #ddd;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 0 10px;
      box-sizing: border-box;
      overflow-x: auto;
    }
    #toolbar button, #toolbar label, #toolbar select, #toolbar input[type="color"], #toolbar input[type="range"] {
      margin-right: 8px;
    }
    #main-container {
      position: absolute;
      left: 0;
      top: 60px;
      bottom: 0;
      right: 350px;
      overflow: hidden;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: visible;
      background: #eaeaea;
      cursor: crosshair;
    }
    #board-canvas {
      background: #fff;
      box-shadow: 0 0 6px #bbb;
      position: absolute;
      left: 0; top: 0;
      z-index: 1;
      touch-action: none;
      user-select: none;
    }
    .sticky-note {
      min-width: 120px;
      min-height: 80px;
      max-width: 250px;
      max-height: 300px;
      position: absolute;
      z-index: 20;
      background: #fffbcc;
      border: 1.5px solid #e6d97b;
      border-radius: 8px;
      box-shadow: 2px 2px 8px #ccc;
      padding: 5px 26px 5px 8px;
      box-sizing: border-box;
      cursor: grab;
      transition: box-shadow 0.2s;
      resize: both;
      overflow: auto;
    }
    .sticky-note .note-delete {
      position: absolute;
      top: 4px; right: 4px;
      background: #f44;
      color: #fff;
      border: none;
      border-radius: 3px;
      width: 20px; height: 20px;
      cursor: pointer;
      font-size: 14px;
      line-height: 16px;
      z-index: 50;
    }
    .sticky-note .note-color {
      position: absolute;
      bottom: 4px; right: 4px;
    }
    .sticky-note textarea {
      width: 100%;
      height: 80%;
      border: none;
      background: none;
      resize: none;
      font-size: 16px;
      font-family: inherit;
      outline: none;
      color: #333;
      background: transparent;
      margin-top: 5px;
    }
    .image-item {
      position: absolute;
      z-index: 15;
      border: 1.5px dashed #888;
      background: #fff;
      cursor: move;
      resize: both;
      overflow: hidden;
      transition: box-shadow 0.2s;
      box-shadow: 2px 2px 8px #ccc;
    }
    .image-item.selected {
      border: 2px solid #2196f3;
      box-shadow: 0 0 16px #2196f366;
    }
    .image-item .img-resize {
      position: absolute;
      width: 12px; height: 12px;
      right: -8px; bottom: -8px;
      background: #2196f3;
      border-radius: 50%;
      cursor: se-resize;
      z-index: 30;
      border: 2px solid #fff;
    }
    #side-panel {
      position: fixed;
      top: 0; right: 0; bottom: 0;
      width: 350px;
      background: #f8f8fa;
      border-left: 1px solid #ddd;
      z-index: 20;
      display: flex;
      flex-direction: column;
    }
    #side-panel h3 {
      margin: 10px 10px 3px 10px;
      font-size: 18px;
      color: #333;
    }
    #chat-panel {
      flex: 2;
      display: flex;
      flex-direction: column;
      border-bottom: 1px solid #ddd;
    }
    #chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      font-size: 15px;
      background: #f4f4fc;
      border-radius: 5px;
      margin: 0 10px 5px 10px;
    }
    .chat-msg {
      margin-bottom: 8px;
      padding: 5px 10px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 1px 1px 3px #eee;
      word-break: break-word;
      color: #222;
      max-width: 90%;
    }
    #chat-input-bar {
      display: flex;
      gap: 6px;
      padding: 6px 10px 10px 10px;
    }
    #chat-input-bar input {
      flex: 1;
      font-size: 15px;
      border: 1px solid #bbb;
      border-radius: 5px;
      padding: 6px;
    }
    #chat-input-bar button {
      font-size: 15px;
      background: #2196f3;
      color: #fff;
      border: none;
      border-radius: 5px;
      padding: 0 12px;
      cursor: pointer;
    }
    #history-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding-bottom: 5px;
    }
    #history-list {
      flex: 1;
      overflow-y: auto;
      margin: 0 10px 0 10px;
      background: #f4f4fc;
      border-radius: 5px;
      padding: 10px;
      font-size: 14px;
    }
    .history-item {
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
      border: 1px solid #eee;
      transition: background 0.15s;
    }
    .history-item:hover {
      background: #e3f2fd;
    }
    /* Tooltips */
    [tooltip] {
      position: relative;
    }
    [tooltip]:hover::after {
      content: attr(tooltip);
      position: absolute;
      left: 50%; bottom: 120%;
      transform: translateX(-50%);
      background: #444;
      color: #fff;
      padding: 2px 7px;
      border-radius: 4px;
      font-size: 13px;
      white-space: nowrap;
      z-index: 1000;
      pointer-events: none;
    }
    @media (max-width: 900px) {
      #side-panel { width: 100vw; right: 0; left: 0; top: auto; bottom: 0; height: 320px; }
      #main-container { right: 0; bottom: 320px; }
      #toolbar { right: 0; }
    }
  </style>
</head>
<body>
  <!-- Toolbar -->
  <div id="toolbar">
    <button id="select-pen" tooltip="Pen/Brush Tool">‚úèÔ∏è</button>
    <button id="select-eraser" tooltip="Eraser Tool">üßΩ</button>
    <select id="shape-tool" tooltip="Shape Tool">
      <option value="">Shape</option>
      <option value="rect">Rectangle</option>
      <option value="ellipse">Circle</option>
      <option value="line">Line</option>
      <option value="arrow">Arrow</option>
    </select>
    <button id="select-text" tooltip="Text Tool">üî§</button>
    <button id="add-sticky" tooltip="Add Sticky Note">üóíÔ∏è</button>
    <input type="color" id="color-picker" value="#222222" tooltip="Line/Shape/Text Color">
    <input type="range" id="brush-size" min="1" max="24" value="3" tooltip="Thickness" style="width:65px;">
    <input type="number" id="text-size" min="10" max="72" value="22" tooltip="Text Size" style="width:55px;">
    <button id="undo-btn" tooltip="Undo"><b>‚éå</b></button>
    <button id="redo-btn" tooltip="Redo"><b>‚Üª</b></button>
    <button id="zoom-in-btn" tooltip="Zoom In">+</button>
    <button id="zoom-out-btn" tooltip="Zoom Out">‚àí</button>
    <button id="reset-pan-btn" tooltip="Reset View">üß≠</button>
    <input type="file" id="img-upload" accept="image/*" style="display:none;">
    <button id="img-upload-btn" tooltip="Upload Image">üñºÔ∏è</button>
    <button id="export-btn" tooltip="Export as Image">üíæ</button>
  </div>
  <!-- Main Whiteboard Area -->
  <div id="main-container">
    <div id="canvas-container">
      <canvas id="board-canvas" width="3200" height="2400"></canvas>
      <!-- Sticky notes and images appended here -->
    </div>
  </div>
  <!-- Side Panel -->
  <div id="side-panel">
    <h3>Chat / Comments</h3>
    <div id="chat-panel">
      <div id="chat-messages"></div>
      <div id="chat-input-bar">
        <input type="text" id="chat-input" placeholder="Type message..." maxlength="250">
        <button id="chat-send">Send</button>
      </div>
    </div>
    <h3>Board History</h3>
    <div id="history-panel">
      <div id="history-list"></div>
    </div>
  </div>
  <script>
    // --- Whiteboard State ---
    const canvas = document.getElementById('board-canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    let tool = 'pen';
    let shapeType = '';
    let drawing = false, erasing = false;
    let points = [];
    let startX = 0, startY = 0;
    let brushColor = '#222222';
    let brushSize = 3;
    let textSize = 22;
    let textToolActive = false;
    let panX = 0, panY = 0, zoom = 1;
    let isPanning = false, lastPanX = 0, lastPanY = 0;
    let lastMouseX = 0, lastMouseY = 0;
    let shapes = [], actions = [], redoStack = [];
    let stickyNotes = [];
    let images = [];

    // --- Canvas Constants ---
    const CANVAS_W = canvas.width;
    const CANVAS_H = canvas.height;

    // --- Toolbar Elements ---
    const penBtn = document.getElementById('select-pen');
    const eraserBtn = document.getElementById('select-eraser');
    const shapeSelect = document.getElementById('shape-tool');
    const textBtn = document.getElementById('select-text');
    const stickyBtn = document.getElementById('add-sticky');
    const colorPicker = document.getElementById('color-picker');
    const brushSizeInput = document.getElementById('brush-size');
    const textSizeInput = document.getElementById('text-size');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const zoomInBtn = document.getElementById('zoom-in-btn');
    const zoomOutBtn = document.getElementById('zoom-out-btn');
    const resetPanBtn = document.getElementById('reset-pan-btn');
    const imgUpload = document.getElementById('img-upload');
    const imgUploadBtn = document.getElementById('img-upload-btn');
    const exportBtn = document.getElementById('export-btn');

    // --- Event Listeners for Toolbar ---
    penBtn.onclick = () => { setTool('pen'); };
    eraserBtn.onclick = () => { setTool('eraser'); };
    shapeSelect.onchange = () => { setTool('shape'); shapeType = shapeSelect.value; if (!shapeType) setTool('pen'); };
    textBtn.onclick = () => { setTool('text'); };
    stickyBtn.onclick = () => { createStickyNote(panX + CANVAS_W/2/zoom - 70, panY + CANVAS_H/2/zoom - 40); };
    colorPicker.oninput = e => { brushColor = colorPicker.value; };
    brushSizeInput.oninput = e => { brushSize = parseInt(brushSizeInput.value); };
    textSizeInput.oninput = e => { textSize = parseInt(textSizeInput.value); };
    undoBtn.onclick = () => { undo(); };
    redoBtn.onclick = () => { redo(); };
    zoomInBtn.onclick = () => { setZoom(zoom * 1.15, CANVAS_W/2, CANVAS_H/2); };
    zoomOutBtn.onclick = () => { setZoom(zoom / 1.15, CANVAS_W/2, CANVAS_H/2); };
    resetPanBtn.onclick = () => { panX = 0; panY = 0; setZoom(1, CANVAS_W/2, CANVAS_H/2, true); };
    imgUploadBtn.onclick = () => { imgUpload.click(); };
    imgUpload.onchange = handleImageUpload;
    exportBtn.onclick = exportAsImage;

    function setTool(t) {
      tool = t;
      textToolActive = (t === 'text');
      erasing = (t === 'eraser');
      penBtn.style.background = t === 'pen' ? '#e3f2fd' : '';
      eraserBtn.style.background = t === 'eraser' ? '#e3f2fd' : '';
      textBtn.style.background = t === 'text' ? '#e3f2fd' : '';
      shapeSelect.style.background = t === 'shape' ? '#e3f2fd' : '';
    }

    // --- Canvas Helpers: Pan & Zoom ---
    function setZoom(newZoom, centerX, centerY, reset=false) {
      if (newZoom < 0.2 || newZoom > 5) return;
      // Adjust pan so (centerX, centerY) stays under the cursor
      if (!reset) {
        let wx = (centerX - panX) / zoom;
        let wy = (centerY - panY) / zoom;
        panX = centerX - wx * newZoom;
        panY = centerY - wy * newZoom;
      } else {
        panX = 0; panY = 0;
      }
      zoom = newZoom;
      updateCanvas();
      updateStickyAndImages();
    }

    // --- Drawing Logic ---
    function getCanvasCoords(clientX, clientY) {
      // Map from screen to canvas (with pan/zoom)
      const rect = canvas.getBoundingClientRect();
      let x = (clientX - rect.left - panX) / zoom;
      let y = (clientY - rect.top - panY) / zoom;
      return {x, y};
    }

    function drawAll() {
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0); // reset
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      ctx.save();
      ctx.setTransform(zoom,0,0,zoom,panX,panY);
      // Draw all actions
      for (let act of actions) {
        if (act.type === 'pen') drawStroke(act, false);
        else if (act.type === 'eraser') drawStroke(act, true);
        else if (act.type === 'shape') drawShape(act);
        else if (act.type === 'text') drawText(act);
        else if (act.type === 'image') drawImageOnCanvas(act);
      }
      ctx.restore();
    }

    function drawStroke(act, erase) {
      ctx.save();
      ctx.strokeStyle = erase ? '#fff' : act.color;
      ctx.lineWidth = act.size || 3;
      ctx.lineCap = 'round';
      ctx.globalAlpha = 1.0;
      ctx.beginPath();
      for (let i=0; i<act.points.length; i++) {
        let p = act.points[i];
        if (i===0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawShape(act) {
      ctx.save();
      ctx.strokeStyle = act.color;
      ctx.lineWidth = act.size || 3;
      ctx.globalAlpha = 1.0;
      let {x0, y0, x1, y1, shape} = act;
      if (shape === 'rect') {
        ctx.strokeRect(x0, y0, x1-x0, y1-y0);
      } else if (shape === 'ellipse') {
        ctx.beginPath();
        ctx.ellipse((x0+x1)/2, (y0+y1)/2, Math.abs((x1-x0)/2), Math.abs((y1-y0)/2), 0, 0, 2*Math.PI);
        ctx.stroke();
      } else if (shape === 'line') {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
      } else if (shape === 'arrow') {
        // Draw line
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
        // Arrowhead
        let angle = Math.atan2(y1 - y0, x1 - x0);
        let len = Math.max(18, act.size*6);
        for (let delta of [Math.PI/8, -Math.PI/8]) {
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(
            x1 - len * Math.cos(angle - delta),
            y1 - len * Math.sin(angle - delta)
          );
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawText(act) {
      ctx.save();
      ctx.font = `bold ${act.size||22}px Arial`;
      ctx.fillStyle = act.color;
      ctx.globalAlpha = 1.0;
      ctx.textBaseline = 'top';
      ctx.fillText(act.text, act.x, act.y);
      ctx.restore();
    }

    function drawImageOnCanvas(act) {
      if (act.img) {
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.drawImage(act.img, act.x, act.y, act.width, act.height);
        ctx.restore();
      }
    }

    // --- Mouse & Drawing Events ---
    canvas.onmousedown = e => {
      if (textToolActive) return; // handled separately
      if (isOverStickyOrImage(e)) return;
      if (e.button===1) { // Middle mouse for pan
        isPanning = true; lastPanX = e.clientX; lastPanY = e.clientY; return;
      }
      const {x, y} = getCanvasCoords(e.clientX, e.clientY);
      if (tool==='pen' || tool==='eraser') {
        drawing = true;
        points = [{x, y}];
      } else if (tool==='shape' && shapeType) {
        drawing = true;
        startX = x; startY = y;
        points = [{x, y}];
      }
    };
    canvas.onmousemove = e => {
      if (isPanning) {
        panX += e.clientX - lastPanX;
        panY += e.clientY - lastPanY;
        lastPanX = e.clientX; lastPanY = e.clientY;
        updateCanvas();
        updateStickyAndImages();
        return;
      }
      if (drawing && (tool==='pen'||tool==='eraser')) {
        const {x, y} = getCanvasCoords(e.clientX, e.clientY);
        points.push({x, y});
        drawAll();
        drawStroke({points, color: brushColor, size: brushSize}, tool==='eraser');
      } else if (drawing && tool==='shape' && shapeType) {
        const {x, y} = getCanvasCoords(e.clientX, e.clientY);
        points[1] = {x, y};
        drawAll();
        drawShape({
          shape: shapeType,
          x0: points[0].x, y0: points[0].y,
          x1: x, y1: y,
          color: brushColor,
          size: brushSize
        });
      }
    };
    canvas.onmouseup = e => {
      if (isPanning) { isPanning = false; return; }
      if (drawing && (tool==='pen'||tool==='eraser')) {
        actions.push({
          type: tool,
          points: [...points],
          color: brushColor,
          size: brushSize
        });
        drawing = false; points = [];
        saveHistory();
      } else if (drawing && tool==='shape' && shapeType) {
        const {x, y} = getCanvasCoords(e.clientX, e.clientY);
        actions.push({
          type: 'shape',
          shape: shapeType,
          x0: points[0].x, y0: points[0].y,
          x1: x, y1: y,
          color: brushColor,
          size: brushSize
        });
        drawing = false; points = [];
        saveHistory();
      }
      drawAll();
    };
    canvas.onmouseleave = e => { drawing = false; isPanning = false; };

    // --- Touch Events for Pan/Draw ---
    canvas.addEventListener('touchstart', function(e){
      if (e.touches.length===2) { isPanning = true; lastPanX = e.touches[0].clientX; lastPanY = e.touches[0].clientY; return; }
      if (textToolActive) return;
      const {x, y} = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
      if (tool==='pen' || tool==='eraser') {
        drawing = true; points = [{x, y}];
      } else if (tool==='shape' && shapeType) {
        drawing = true; startX = x; startY = y; points = [{x, y}];
      }
    });
    canvas.addEventListener('touchmove', function(e){
      if (isPanning) {
        panX += e.touches[0].clientX - lastPanX;
        panY += e.touches[0].clientY - lastPanY;
        lastPanX = e.touches[0].clientX; lastPanY = e.touches[0].clientY;
        updateCanvas();
        updateStickyAndImages();
        return;
      }
      if (drawing && (tool==='pen'||tool==='eraser')) {
        const {x, y} = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
        points.push({x, y});
        drawAll();
        drawStroke({points, color: brushColor, size: brushSize}, tool==='eraser');
      } else if (drawing && tool==='shape' && shapeType) {
        const {x, y} = getCanvasCoords(e.touches[0].clientX, e.touches[0].clientY);
        points[1] = {x, y};
        drawAll();
        drawShape({
          shape: shapeType,
          x0: points[0].x, y0: points[0].y,
          x1: x, y1: y,
          color: brushColor,
          size: brushSize
        });
      }
      e.preventDefault();
    }, {passive: false});
    canvas.addEventListener('touchend', function(e){
      if (isPanning) { isPanning = false; return; }
      if (drawing && (tool==='pen'||tool==='eraser')) {
        actions.push({
          type: tool,
          points: [...points],
          color: brushColor,
          size: brushSize
        });
        drawing = false; points = [];
        saveHistory();
      } else if (drawing && tool==='shape' && shapeType) {
        const {x, y} = points[1] || points[0];
        actions.push({
          type: 'shape',
          shape: shapeType,
          x0: points[0].x, y0: points[0].y,
          x1: x, y1: y,
          color: brushColor,
          size: brushSize
        });
        drawing = false; points = [];
        saveHistory();
      }
      drawAll();
    });

    // --- Mouse Wheel for Zoom ---
    canvas.onwheel = function(e) {
      e.preventDefault();
      let factor = e.deltaY < 0 ? 1.1 : 0.9;
      setZoom(zoom * factor, e.offsetX, e.offsetY);
    };

    // --- Text Tool ---
    canvas.onclick = function(e) {
      if (!textToolActive) return;
      if (isOverStickyOrImage(e)) return;
      const {x, y} = getCanvasCoords(e.clientX, e.clientY);
      let t = prompt('Enter text:');
      if (t && t.trim()) {
        actions.push({
          type: 'text',
          text: t.trim(),
          x, y,
          color: brushColor,
          size: textSize
        });
        saveHistory();
        drawAll();
      }
    };

    // --- Undo / Redo ---
    function undo() {
      if (actions.length > 0) {
        redoStack.push(actions.pop());
        drawAll();
        saveHistory();
      }
    }
    function redo() {
      if (redoStack.length > 0) {
        actions.push(redoStack.pop());
        drawAll();
        saveHistory();
      }
    }

    // --- Sticky Notes ---
    function createStickyNote(x, y) {
      let note = document.createElement('div');
      note.className = "sticky-note";
      note.style.left = (x*zoom+panX) + 'px';
      note.style.top = (y*zoom+panY) + 'px';
      note.style.background = '#fffbcc';
      note.style.width = '140px';
      note.style.height = '110px';
      note.innerHTML = `
        <button class="note-delete" title="Delete">√ó</button>
        <textarea>Sticky note...</textarea>
        <input type="color" class="note-color" value="#fffbcc" title="Change color">
      `;
      container.appendChild(note);

      let offsetX, offsetY, dragging = false;
      note.onmousedown = function(e) {
        if (e.target.classList.contains('note-delete')) return;
        dragging = true;
        offsetX = e.offsetX;
        offsetY = e.offsetY;
        note.style.zIndex = 30;
        document.body.style.userSelect = 'none';
      };
      document.addEventListener('mousemove', function(ev) {
        if (!dragging) return;
        note.style.left = (ev.clientX - offsetX) + 'px';
        note.style.top = (ev.clientY - offsetY) + 'px';
      });
      document.addEventListener('mouseup', function(ev) {
        dragging = false;
        note.style.zIndex = 20;
        document.body.style.userSelect = '';
      });
      note.querySelector('.note-delete').onclick = function() {
        note.remove();
      };
      note.querySelector('.note-color').oninput = function(e) {
        note.style.background = e.target.value;
      };
      // Save to stickyNotes array for board history (position, color, text)
      stickyNotes.push(note);
      updateStickyAndImages();
    }

    function updateStickyAndImages() {
      // Reposition sticky notes and images to stay in view with pan/zoom.
      for (let note of stickyNotes) {
        let left = parseFloat(note.style.left) || 0;
        let top = parseFloat(note.style.top) || 0;
        note.style.transform = `scale(${zoom})`;
      }
      for (let img of images) {
        img.style.transform = `scale(${zoom})`;
      }
    }

    function isOverStickyOrImage(e) {
      return Array.from(document.elementsFromPoint(e.clientX, e.clientY)).some(
        el => el.classList.contains('sticky-note') || el.classList.contains('image-item')
      );
    }

    // --- Image Upload, Move, Resize ---
    function handleImageUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new window.Image();
      img.onload = function() {
        let imgDiv = document.createElement('div');
        imgDiv.className = 'image-item';
        imgDiv.style.left = (panX + 100) + 'px';
        imgDiv.style.top = (panY + 100) + 'px';
        imgDiv.style.width = img.width > 350 ? '350px' : img.width + 'px';
        imgDiv.style.height = img.height > 250 ? '250px' : img.height + 'px';
        imgDiv.innerHTML = `<img src="${url}" style="width:100%;height:100%;display:block;">
          <div class="img-resize"></div>`;
        container.appendChild(imgDiv);
        images.push(imgDiv);

        // Drag
        let dragging = false, dragX, dragY, startX, startY;
        imgDiv.onmousedown = function(ev) {
          if (ev.target.classList.contains('img-resize')) return;
          dragging = true; dragX = ev.clientX; dragY = ev.clientY;
          startX = parseFloat(imgDiv.style.left); startY = parseFloat(imgDiv.style.top);
          imgDiv.classList.add('selected');
          document.body.style.userSelect = 'none';
        };
        document.addEventListener('mousemove', function(ev) {
          if (!dragging) return;
          imgDiv.style.left = (startX + (ev.clientX-dragX)) + 'px';
          imgDiv.style.top = (startY + (ev.clientY-dragY)) + 'px';
        });
        document.addEventListener('mouseup', function(ev) {
          dragging = false; imgDiv.classList.remove('selected');
          document.body.style.userSelect = '';
        });
        // Resize
        let resizing = false, resizeStartX, resizeStartY, startW, startH;
        imgDiv.querySelector('.img-resize').onmousedown = function(ev) {
          resizing = true; resizeStartX = ev.clientX; resizeStartY = ev.clientY;
          startW = parseFloat(imgDiv.style.width); startH = parseFloat(imgDiv.style.height);
          ev.stopPropagation();
        };
        document.addEventListener('mousemove', function(ev) {
          if (!resizing) return;
          let w = Math.max(30, startW + (ev.clientX - resizeStartX));
          let h = Math.max(30, startH + (ev.clientY - resizeStartY));
          imgDiv.style.width = w + 'px';
          imgDiv.style.height = h + 'px';
        });
        document.addEventListener('mouseup', function() { resizing = false; });

        // Save image to board actions
        actions.push({
          type: 'image',
          x: (parseFloat(imgDiv.style.left)-panX)/zoom,
          y: (parseFloat(imgDiv.style.top)-panY)/zoom,
          width: parseFloat(imgDiv.style.width)/zoom,
          height: parseFloat(imgDiv.style.height)/zoom,
          src: url,
          img: img
        });
        saveHistory();
        drawAll();
      };
      img.src = url;
      imgUpload.value = '';
    }

    // --- Export as Image ---
    function exportAsImage() {
      // Hide all sticky notes and images for export
      for (let note of stickyNotes) note.style.display = 'none';
      for (let img of images) img.style.display = 'none';
      drawAll();
      setTimeout(()=>{
        let link = document.createElement('a');
        link.download = 'whiteboard.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        for (let note of stickyNotes) note.style.display = '';
        for (let img of images) img.style.display = '';
        drawAll();
      }, 100);
    }

    // --- Board History ---
    let boardHistory = [], historyPointer = -1;
    function saveHistory() {
      // Save every 2 actions, or on undo/redo
      if (boardHistory.length>0 && actions.length === boardHistory[boardHistory.length-1].actionsLen) return;
      let snapshot = {
        actions: JSON.stringify(actions),
        actionsLen: actions.length,
        time: new Date().toLocaleTimeString()
      };
      boardHistory = boardHistory.slice(0, historyPointer+1);
      boardHistory.push(snapshot);
      historyPointer = boardHistory.length-1;
      updateHistoryList();
    }
    function updateHistoryList() {
      let hist = document.getElementById('history-list');
      hist.innerHTML = '';
      boardHistory.forEach((h, i) => {
        let div = document.createElement('div');
        div.className = 'history-item';
        div.textContent = `Step ${i+1} @ ${h.time}`;
        div.onclick = ()=>{ loadHistory(i); };
        hist.appendChild(div);
      });
      hist.scrollTop = hist.scrollHeight;
    }
    function loadHistory(idx) {
      if (idx<0 || idx>=boardHistory.length) return;
      let h = boardHistory[idx];
      actions = JSON.parse(h.actions);
      historyPointer = idx;
      drawAll();
    }

    // --- Chat/Comment Panel ---
    const chatInput = document.getElementById('chat-input');
    const chatSend = document.getElementById('chat-send');
    const chatMessages = document.getElementById('chat-messages');
    chatSend.onclick = sendChat;
    chatInput.onkeydown = (e)=>{ if (e.key==='Enter') sendChat(); };
    function sendChat() {
      let msg = chatInput.value.trim();
      if (!msg) return;
      let div = document.createElement('div');
      div.className = 'chat-msg';
      div.textContent = msg;
      chatMessages.appendChild(div);
      chatInput.value = '';
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // --- Initial Board Setup ---
    function updateCanvas() { drawAll(); }
    function init() {
      setTool('pen');
      drawAll();
      saveHistory();
    }
    init();

    // --- Accessibility: Keyboard Shortcuts ---
    document.addEventListener('keydown', function(e){
      if (e.target === chatInput) return;
      if (e.ctrlKey && e.key==='z') { undo(); }
      else if (e.ctrlKey && e.key==='y') { redo(); }
      else if (e.key==='p') { setTool('pen'); }
      else if (e.key==='e') { setTool('eraser'); }
      else if (e.key==='t') { setTool('text'); }
      else if (e.key==='n') { createStickyNote(panX+CANVAS_W/2/zoom, panY+CANVAS_H/2/zoom); }
      else if (e.key==='s' && e.ctrlKey) { exportAsImage(); e.preventDefault(); }
      else if (e.key==='+') { setZoom(zoom*1.15, CANVAS_W/2, CANVAS_H/2); }
      else if (e.key==='-') { setZoom(zoom/1.15, CANVAS_W/2, CANVAS_H/2); }
    });

    // --- Responsive ---
    window.addEventListener('resize', updateStickyAndImages);

  </script>
</body>
</html>
